{
  "components": {
    "component": [
      {
        "name": "actionListener",
        "description": "Register an ActionListener instance on the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "Value binding expression that evaluates to an object that implements jakarta.faces.event.ActionListener.",
            "name": "binding",
            "required": "false",
            "type": "jakarta.faces.event.ActionListener"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Fully qualified Java class name of an ActionListener to be created and registered.",
            "name": "type",
            "required": "false",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "ajax",
        "description": "Register an AjaxBehavior instance on one or more UIComponents implementing the ClientBehaviorHolder interface. This tag may be nested witin a single component (enabling Ajax for a single component), or it may be \"wrapped\" around multiple components (enabling Ajax for many components). The String value for ids specified for execute and render may be specified as a search expression as outlined in the JavaDocs for UIComponent.findComponent(). The implementation must resolve these ids as specified for UIComponent.findComponent(). For example, consider the following Facelets code. <h:form id=\"form_1\"> &nbsp; <h:panelGrid id=\"panel_1\" rows=\"2\"> &nbsp; &nbsp; <!-- content irrelevant --> &nbsp; </h:panelGrid> </h:form> &nbsp; <h:form id=\"form_2\"> &nbsp; <h:commandButton id=\"button\"> &nbsp; &nbsp; <f:ajax render=\":form1:panel_1 panel_2\" /> &nbsp; </h:commandButton> &nbsp; <h:panelGrid id=\"panel_2\"> &nbsp; &nbsp; <!-- content irrelevant --> &nbsp; </h:panelGrid> </h:form>  When the button is pressed, panel_1, in form_1 will be re-rendered, along with panel_2 in form_2.",
        "attribute": [
          {
            "description": "If less than delay milliseconds elapses between calls to request() only the most recent one is sent and all other requests are discarded. If this option is not specified, or if the value of delay is the literal string 'none' without the quotes, no delay is used.",
            "name": "delay",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "A value of \"true\" indicates the AjaxBehavior should not be rendered. A value of \"false\" indicates the AjaxBehavior should be rendered. \"false\" is the default.",
            "name": "disabled",
            "required": "false",
            "type": "java.lang.Boolean"
          },
          {
            "description": "A String or ValueExpression (that evalulates to a String) identifying the type of event the Ajax action will apply to. If specified, it must be one of the events supported by the component the Ajax behavior is being applied to. For HTML components this would be the set of supported DOM events for the component, plus \"action\" for Faces ActionSource components and \"valueChange\" for Faces EditableValueHolder components. If not specified, the default event is determined for the component. The DOM event name is the actual DOM event name (for example: \"click\") as opposed to (for example: \"onclick\").",
            "name": "event",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Evaluates to Collection<String>. This is a space separated list of search expressions to components that will participate in the \"execute\" portion of the Request Processing Lifecycle. See the javadoc for SearchKeywordResolver for the complete list of keywords. If a literal is specified the ids must be space delimited. If not specified, the default value of \"@this\" is assumed. For example, @this clientIdOne clientIdTwo. When nested within a composite component, and the value contains or implies the keyword @this, then the keyword must be remapped to the targets attribute of the associated <composite:clientBehavior> declaration, if any, else if the value is not an absolute search expression, then it must be reinterpreted relative to the location of the <f:ajax> declaration.",
            "name": "execute",
            "required": "false",
            "type": "java.util.Collection"
          },
          {
            "description": "If \"true\" behavior events generated from this behavior are broadcast during Apply Request Values phase. Otherwise, the events will be broadcast during Invoke Aplications phase",
            "name": "immediate",
            "required": "false",
            "type": "java.lang.Boolean"
          },
          {
            "description": "Method expression referencing a method that will be called when an AjaxBehaviorEvent has been broadcast for the listener.",
            "name": "listener",
            "required": "false",
            "method-signature": "public void processAjaxBehavior(jakarta.faces.event.AjaxBehaviorEvent event) throws jakarta.faces.event.AbortProcessingException"
          },
          {
            "description": "The name of the JavaScript function that will handle errors.",
            "name": "onerror",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "The name of the JavaScript function that will handle UI events.",
            "name": "onevent",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Evaluates to Collection<String>. The search expressions to components that will participate in the \"render\" portion of the Request Processing Lifecycle. See the javadoc for SearchKeywordResolver for the complete list of keywords. If a literal is specified the identifiers must be space delimited. If not specified, the default value of \"@none\" is assumed. For example, @this clientIdOne clientIdTwo. When nested within a composite component, and the value contains or implies the keyword @this, then the keyword must be remapped to the client ID of the associated <composite:implementation>, else if the value is not an absolute search expression, then it must be reinterpreted relative to the location of the <f:ajax> declaration.",
            "name": "render",
            "required": "false",
            "type": "java.util.Collection"
          },
          {
            "description": "Reset specific input values. Interpret the value of the render attribute as a space separated list of client identifiers suitable for passing directly to UIViewRoot.resetValues(). The implementation must cause an ActionListener to be attached to the ActionSource component in which this tag is nested that calls UIViewRoot.resetValues() passing the value of the render attribute as the argument.",
            "name": "resetValues",
            "required": "false",
            "type": "java.lang.Boolean"
          }
        ]
      },
      {
        "name": "attribute",
        "description": "Add an attribute to the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "The name of the component attribute to be set.",
            "name": "name",
            "type": "java.lang.String"
          },
          {
            "description": "The value of the component attribute to be set.",
            "name": "value",
            "type": "java.lang.Object"
          }
        ]
      },
      {
        "name": "attributes",
        "description": "Add attributes to the UIComponent associated with the closest parent UIComponent tag. For each Map.Entry in the Map<String, Object> referenced by the value attribute of this tag, take the following action. If parent.getAttributes().containsKey(entry.getKey()) returns true, take no action for this entry. Otherwise, if entry.getValue() is a ValueExpression call parent.setValueExpression(entry.getKey(), entry.getValue()). Otherwise, call parent.getAttributes.put(entry.getKey(), entry.getValue()).",
        "attribute": {
          "description": "An EL ValueExpression that evaluates to a Map<String, Object>.",
          "name": "value",
          "required": "true",
          "type": "java.util.Map"
        }
      },
      {
        "name": "convertDateTime",
        "description": "Register a DateTimeConverter instance on the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an instance of jakarta.faces.convert.DateTimeConverter.",
            "name": "binding",
            "type": "jakarta.faces.convert.DateTimeConverter"
          },
          {
            "description": "Predefined formatting style which determines how the date component of a date string is to be formatted and parsed. Applied only if type is \"date\", \"both\", \"localDate\", \"localDateTime\", or \"zonedDateTime\". Valid values are \"default\", \"short\", \"medium\", \"long\", and \"full\". Default value is \"default\". If a java.time formatter is being used, yet the dateStyle is set to \"default\", the value \"medium\" is assumed.",
            "name": "dateStyle",
            "type": "java.lang.String"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Locale whose predefined styles for dates and times are used during formatting or parsing. If not specified, the Locale returned by FacesContext.getViewRoot().getLocale() will be used. Value must be either a VB expression that evaluates to a java.util.Locale instance, or a String that is valid to pass as the first argument to the constructor java.util.Locale(String language, String country). The empty string is passed as the second argument.",
            "name": "locale",
            "required": "false",
            "type": "java.lang.Object"
          },
          {
            "description": "Custom formatting pattern which determines how the date/time string should be formatted and parsed.",
            "name": "pattern",
            "type": "java.lang.String"
          },
          {
            "description": "Predefined formatting style which determines how the time component of a date string is to be formatted and parsed. Applied only if type is \"time\", \"both\", \"localTime\" or \"offsetTime\". Valid values are \"default\", \"short\", \"medium\", \"long\", and \"full\". Default value is \"default\". If a java.time formatter is being used, yet the timeStyle is set to \"default\", the value \"medium\" is assumed.",
            "name": "timeStyle",
            "type": "java.lang.String"
          },
          {
            "description": "Time zone in which to interpret any time information in the date String. Value must be either a ValueExpression that evaluates to a java.util.TimeZone instance, or a String that is a timezone ID as described in the javadocs for java.util.TimeZone.getTimeZone().",
            "name": "timeZone",
            "type": "java.lang.Object"
          },
          {
            "description": "Specifies what contents the string value will be formatted to include, or parsed expecting. Valid values are \"date\", \"time\", \"both\", \"localDate\", \"localDateTime\", \"localTime\", \"offsetTime\", \"offsetDateTime\", and \"zonedDateTime\". The values starting with \"local\", \"offset\" and \"zoned\" correspond to Java SE 8 Date Time API classes in package java.time with the name derived by upper casing the first letter. For example, java.time.LocalDate for the value \"localDate\". Default value is \"date\".",
            "name": "type",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "convertNumber",
        "description": "Register a NumberConverter instance on the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an instance of jakarta.faces.convert.NumberConverter.",
            "name": "binding",
            "type": "jakarta.faces.convert.NumberConverter"
          },
          {
            "description": "ISO 4217 currency code, applied only when formatting currencies.",
            "name": "currencyCode",
            "type": "java.lang.String"
          },
          {
            "description": "Currency symbol, applied only when formatting currencies.",
            "name": "currencySymbol",
            "type": "java.lang.String"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Flag specifying whether formatted output will contain grouping separators. Expressions must evaluate to a boolean. Default value is true.",
            "name": "groupingUsed",
            "type": "java.lang.Boolean"
          },
          {
            "description": "Flag specifying whether only the integer part of the value will be formatted and parsed. Expressions must evaluate to a boolean. Default value is false.",
            "name": "integerOnly",
            "type": "java.lang.Boolean"
          },
          {
            "description": "Locale whose predefined styles for numbers are used during formatting and parsing. If not specified, the Locale returned by FacesContext.getViewRoot().getLocale() will be used. Expressions must evaluate to a java.util.Locale or a String that is valid to pass as the first argument to the constructor java.util.Locale(String language, String country). The empty string is passed as the second argument.",
            "name": "locale",
            "type": "java.lang.Object"
          },
          {
            "description": "Maximum number of digits that will be formatted in the fractional portion of the output. Expressions must evaluate to an int.",
            "name": "maxFractionDigits",
            "type": "java.lang.Integer"
          },
          {
            "description": "Maximum number of digits that will be formatted in the integer portion of the output. Expressions must evaluate to an int.",
            "name": "maxIntegerDigits",
            "type": "java.lang.Integer"
          },
          {
            "description": "Minimum number of digits that will be formatted in the fractional portion of the output. Expressions must evaluate to an int.",
            "name": "minFractionDigits",
            "type": "java.lang.Integer"
          },
          {
            "description": "Minimum number of digits that will be formatted in the integer portion of the output. Expressions must evaluate to an int.",
            "name": "minIntegerDigits",
            "type": "java.lang.Integer"
          },
          {
            "description": "Custom formatting pattern which determins how the number string should be formatted and parsed.",
            "name": "pattern",
            "type": "java.lang.String"
          },
          {
            "description": "Specifies how the number string will be formatted and parsed. Valid values are \"number\", \"currency\", and \"percent\". Default value is \"number\".",
            "name": "type",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "converter",
        "description": "Register a named Converter instance on the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an object that implements jakarta.faces.convert.Converter.",
            "name": "binding",
            "type": "jakarta.faces.convert.Converter"
          },
          {
            "description": "Converter identifier of the Converter instance to be created and registered.",
            "name": "converterId",
            "type": "java.lang.String"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "event",
        "description": "Allow Jakarta Faces page authors to install ComponentSystemEventListener instances on a component in a page.",
        "attribute": [
          {
            "description": "The expression must evaluate to a public method that takes a ComponentSystemEvent parameter, with a return type of void, or to a public method that takes no arguments with a return type of void. In the latter case, the method has no way of easily knowing where the event came from, but this can be useful in cases where a notification is needed that \"an event happened\".",
            "name": "listener",
            "required": "true",
            "method-signature": "public void listener(jakarta.faces.event.ComponentSystemEvent event) throws jakarta.faces.event.AbortProcessingException"
          },
          {
            "description": "Name of the event for which to install a listener. The following table lists the valid values for this attribute, and the corresponding event type for which the listener action is registered.  value for \"type\" tagattribute Type of event sent to listener method   preRenderComponent jakarta.faces.event.PreRenderComponentEvent   preRenderView jakarta.faces.event.PreRenderViewEvent   postAddToView jakarta.faces.event.PostAddToViewEvent   preValidate jakarta.faces.event.PreValidateEvent   postValidate jakarta.faces.event.PostValidateEvent    In addition to these values, the fully qualified class name of anyjava class that extendsjakarta.faces.event.ComponentSystemEvent may be used as thevalue of the \"type\" attribute. Also, the @jakarta.faces.event.NamedEvent annotation maybe attached to any java class that extendsjakarta.faces.event.ComponentSystemEvent. This enables thatevent to be referenced from this attribute, as descibed in the javadocsfor @NamedEvent.",
            "name": "type",
            "required": "true",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "facet",
        "description": "Register a named facet on the UIComponent associated with the closest parent UIComponent tag.  When the facet contains more than one child the children will be automatically put in a container UIPanel.",
        "attribute": {
          "description": "Name of the facet to be created.",
          "name": "name",
          "required": "true",
          "type": "java.lang.String"
        }
      },
      {
        "name": "importConstants",
        "description": "Used inside of the metadata facet of a view, this tag will import a mapping of all constant field values of the given type in the current view. Constant field values are all public static final fields of the given type. The map key represents the constant field name as String. The map value represents the actual constant field value. This works for classes, interfaces and enums.",
        "attribute": [
          {
            "description": "The fully qualified name of the type to import the constant field values for.",
            "name": "type",
            "required": "true",
            "type": "java.lang.String"
          },
          {
            "description": "Name of request scope attribute under which constants will be exposed as a Map. Defaults to the simple name of the given type.",
            "name": "var",
            "required": "false"
          }
        ]
      },
      {
        "name": "loadBundle",
        "description": "Load a resource bundle localized for the Locale of the current view, and expose it as a java.util.Map in the request attributes of the current request under the key specified by the value of the \"var\" attribute of this tag. The Map must behave such that if a get() call is made for a key that does not exist in the Map, the literal string ???KEY??? is returned from the Map, where KEY is the key being looked up in the Map, instead of a MissingResourceException being thrown. If the ResourceBundle does not exist, a TagAttributeException must be thrown.",
        "attribute": [
          {
            "description": "Base name of the resource bundle to be loaded.",
            "name": "basename",
            "type": "java.lang.String"
          },
          {
            "description": "Name of a request scope attribute under which the resource bundle will be exposed as a Map.",
            "name": "var",
            "required": "true",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "metadata",
        "description": "Declare the metadata facet for this view. This must be a direct child of the <f:view>. This tag must reside within the top level XHTML file for the given viewId, or in a template client, but not in a template. The implementation must insure that the direct child of the facet is a UIPanel, even if there is only one child of the facet. The implementation must set the id of the UIPanel to be the value of the UIViewRoot.METADATA_FACET_NAME symbolic constant.  The implementation must allow templating for this element according to the following pattern. template client XHTML view, view01.xhtml  <ui:composition template=\"template.xhtml\"> &nbsp; &nbsp; <ui:define name=\"metadata\"> &nbsp; &nbsp; &nbsp; <f:metadata> &nbsp; &nbsp; &nbsp; &nbsp; <f:viewParam name=\"id\"/> &nbsp; &nbsp; &nbsp; </f:metadata> &nbsp; &nbsp; </ui:define> &nbsp; &nbsp; <ui:define name=\"content\"> &nbsp; &nbsp; &nbsp; &nbsp; <h1>The big news stories of the day</h1> &nbsp; &nbsp; </ui:define> </ui:composition>   Note line 4. The page author must ensure that the <f:metadata> element does not appear on a template or included page. It must reside on the root page that corresponds to the viewId. The template page, template.xhtml  <html xmlns=\"http://www.w3.org/1999/xhtml\" &nbsp; &nbsp; &nbsp; xmlns:ui=\"jakarta.faces.facelets\" &nbsp; &nbsp; &nbsp; xmlns:f=\"jakarta.faces.core\" &nbsp; &nbsp; &nbsp; xml:lang=\"en\" lang=\"en\"> &nbsp; <body> <f:view> &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; <ui:insert name=\"metadata\"/> &nbsp; &nbsp; &nbsp; &nbsp; <div id=\"container\"> &nbsp; &nbsp; &nbsp; &nbsp; <ui:insert name=\"content\"/> &nbsp; &nbsp; </div> </f:view> </body> </html>  The page author is not required to use templating, but if they do, it must be done as shown above, (or with <ui:include> in a similar manner).",
        "attribute": []
      },
      {
        "name": "param",
        "description": "Add a child UIParameter component to the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "ValueExpression to a backing bean property bound to the component instance for the UIComponent created by this tag.",
            "name": "binding",
            "type": "jakarta.faces.component.UIComponent"
          },
          {
            "description": "Flag enabling or disabling the inclusion of the parameter. This flag is consulted by renderers that consider the UIParameter component associated with this  during their rendering. Such renderers include jakarta.faces.Output jakarta.faces.Link and jakarta.faces.OutcomeTarget jakarta.faces.Link.",
            "name": "disable",
            "type": "boolean"
          },
          {
            "description": "Component identifier of the UIParameter component to be created.",
            "name": "id",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Name of the parameter to be created.",
            "name": "name",
            "type": "java.lang.String"
          },
          {
            "description": "Value of the parameter to be set.",
            "name": "value",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "passThroughAttribute",
        "description": "Add an attribute to the passThroughAttributes Map of the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "The name of the pass through attribute. An attribute with this name, and the corresponding value will appear on the outer most markup element in the rendered markup for the component, as specified in the overview for the HTML_BASIC RenderKit. If the name of this attribute conflicts with Renderer specific attribute, the value specified here supercedes the one that would otherwise be rendered by the Renderer",
            "name": "name",
            "required": "true",
            "type": "java.lang.String"
          },
          {
            "description": "The value of the pass through attribute.",
            "name": "value",
            "required": "true",
            "type": "java.lang.Object"
          }
        ]
      },
      {
        "name": "passThroughAttributes",
        "description": "Add attributes to the passThroughAttributes Map of the UIComponent associated with the closest parent UIComponent tag. For each Map.Entry in the Map<String, Object> referenced by the value attribute of this tag, take the following action. Call component.getPassThroughAttributes().put(entry.getKey(), entry.getValue()).",
        "attribute": {
          "description": "An EL ValueExpression that evaluates to a Map<String, Object>.",
          "name": "value",
          "required": "true",
          "type": "java.util.Map"
        }
      },
      {
        "name": "phaseListener",
        "description": "Register a PhaseListener instance on the UIViewRoot in which this tag is nested.",
        "attribute": [
          {
            "description": "Value binding expression that evaluates to an object that implements jakarta.faces.event.PhaseListener.",
            "name": "binding",
            "required": "false",
            "type": "jakarta.faces.event.PhaseListener"
          },
          {
            "description": "Fully qualified Java class name of a PhaseListener to be created and registered.",
            "name": "type",
            "required": "false",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "selectItem",
        "description": "Add a child UISelectItem component to the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "Value binding expression to a backing bean property bound to the component instance for the UIComponent created by this tag.",
            "name": "binding",
            "type": "jakarta.faces.component.UIComponent"
          },
          {
            "description": "Component identifier of the UISelectItem component to be created.",
            "name": "id",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Description of this option, for use in development tools.",
            "name": "itemDescription",
            "type": "java.lang.String"
          },
          {
            "description": "Flag indicating whether the option created by this component is disabled. Expressions must evaluate to a boolean. Default value is false.",
            "name": "itemDisabled",
            "type": "java.lang.Boolean"
          },
          {
            "description": "Flag indicating that characters that are sensitive in the value of the itemLabel attribute must be escaped. This flag is set to \"true\" by default.",
            "name": "itemEscaped",
            "type": "java.lang.String"
          },
          {
            "description": "Label to be displayed to the user for this option.",
            "name": "itemLabel",
            "type": "java.lang.String"
          },
          {
            "description": "Value to be returned to the server if this option is selected by the user.",
            "name": "itemValue",
            "type": "java.lang.String"
          },
          {
            "description": "Flag indicating whether the option created by this component represents the special \"no selection\" option. Expressions must evaluate to a boolean. Default value is false.",
            "name": "noSelectionOption",
            "type": "java.lang.Boolean"
          },
          {
            "description": "Value binding expression pointing at a SelectItem instance containing the information for this option.",
            "name": "value",
            "type": "jakarta.faces.model.SelectItem"
          }
        ]
      },
      {
        "name": "selectItems",
        "description": "Add a child UISelectItems component to the UIComponent associated with the closed parent UIComponent tag. When iterating over the select items, toString() must be called on the string rendered attribute values. Version 2 of the specification introduces several new attributes, described below. These are: var, itemValue, itemLabel, itemDescription, itemDisabled, and itemLabelEscaped.",
        "attribute": [
          {
            "description": "Value binding expression to a backing bean property bound to the component instance for the UIComponent created by this tag.",
            "name": "binding",
            "type": "jakarta.faces.component.UIComponent"
          },
          {
            "description": "Component identifier of the UISelectItems component to be created.",
            "name": "id",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "evaluates to a String that will serve as the description to be shown for the item.",
            "name": "itemDescription",
            "type": "java.lang.String"
          },
          {
            "description": "evaluates to a boolean that will determine if the item value is selectable or not.",
            "name": "itemDisabled",
            "type": "java.lang.Boolean"
          },
          {
            "description": "evaluates to a String that will serve as the label to be shown for the item.",
            "name": "itemLabel",
            "type": "java.lang.String"
          },
          {
            "description": "evaluates to a boolean that willdetermine if the rendered markup for the item receives normal Faces HTMLescaping or not. If not specified, theruntime must behave as if the value were true.",
            "name": "itemLabelEscaped",
            "type": "java.lang.Boolean"
          },
          {
            "description": "This attribute lets you refer to a property of the current member of the collection referenced by the \"value\" attribute, using the value of the \"var\" attribute as the base. For example, #{n.id}.",
            "name": "itemValue",
            "type": "java.lang.Object"
          },
          {
            "description": "Is either an EL expression pointing to the element in the value collection whose value should be marked as a &#8220;no selection&#8221; item, or a literal string that exactly matches the value of the item in the collection that must be marked as the &#8220;no selection&#8221; item. If the user selects such an item and the field is marked as required, then it will not pass validation.",
            "name": "noSelectionValue",
            "type": "java.lang.Boolean"
          },
          {
            "description": "Value expression pointing at any Collection or array. The member elements may be instances of SelectItem or any Java Object. In the case where the member elements are plain Java Objects, several additional attributes must be used by the page author to correctly identify the data to the enclosing UISelectOne or UISelectMany component, as shown in the following example. <h:selectOneListbox size=\"1\" id=\"escape02\" value=\"#{select05NoSelection.initialCollectionValues}\">&nbsp; <f:selectItems value=\"#{select05NoSelection.hobbitList}\"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var=\"n\"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;itemValue=\"#{n.id}\"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;itemLabel=\"#{n.bio}\"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;itemDescription=\"#{n.description}\"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;itemDisabled=\"#{n.disabled}\"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;itemLabelEscaped=\"true\"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;noSelectionValue=\"#{select05NoSelection.hobbitList[0]}\"/></h:selectOneListbox>  In the preceding example, thevalue attribute on line 1 points to aCollection<HobbitBean>. HobbitBean isjust a regular Java Object (POJO) that conforms to JavaBeans namingconventions for its properties. The value attribute online 2 points to a List<HobbitBean>, though it couldjust as well point to a Collection, array, orjakarta.faces.model.DataModel. The attributes on lines 3through 9, inclusive, leverage the fact that the value is a collectionof POJOs.",
            "name": "value",
            "type": "java.lang.Object"
          },
          {
            "description": "Expose the value from the value attribute under this request scoped key so that it may be referred to in EL for the value of other attributes.",
            "name": "var",
            "required": "false"
          }
        ]
      },
      {
        "name": "selectItemGroup",
        "description": "UISelectItemGroup is a component that may be nested inside a UISelectMany or UISelectOne component, and causes the addition of one SelectItemGroup of one or more SelectItem instances to the list of available options in the parent component. This component accepts only children of type UISelectItems or UISelectItem.",
        "attribute": [
          {
            "description": "Component identifier of the UISelectItemGroup component to be created.",
            "name": "id",
            "type": "java.lang.String"
          },
          {
            "description": "Value binding expression to a backing bean property bound to the component instance for the UIComponent created by this tag.",
            "name": "binding",
            "type": "jakarta.faces.component.UIComponent"
          },
          {
            "description": "Label to be displayed to the user for this option group.",
            "name": "itemLabel",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "selectItemGroups",
        "description": "UISelectItemGroups is a component that may be nested inside a UISelectMany or UISelectOne component, and causes the addition of one or more SelectItemGroup of one or more SelectItem instances to the list of available options in the parent component. This component accepts only children of type UISelectItems or UISelectItem.",
        "attribute": [
          {
            "description": "Component identifier of the UISelectItemGroups component to be created.",
            "name": "id",
            "type": "java.lang.String"
          },
          {
            "description": "Value binding expression to a backing bean property bound to the component instance for the UIComponent created by this tag.",
            "name": "binding",
            "type": "jakarta.faces.component.UIComponent"
          },
          {
            "description": "Value expression pointing at any array or Iterable. The member elements may be instances of any type which is acceptable by the value attribute of any nested UISelectItems or UISelectItem component.",
            "name": "value",
            "type": "java.lang.Object"
          },
          {
            "description": "Expose the currently iterated member element from the value attribute under this request scoped key, so that it may be referred to in EL for the value of other attributes of any nested component.",
            "name": "var"
          },
          {
            "description": "Label to be displayed to the user for this option group.",
            "name": "itemLabel",
            "type": "java.lang.String"
          },
          {
            "description": "Flag indicating whether the option group created by this component is disabled. Expressions must evaluate to a boolean. Default value is false.",
            "name": "itemDisabled",
            "type": "java.lang.Boolean"
          }
        ]
      },
      {
        "name": "setPropertyActionListener",
        "description": "Register an ActionListener instance on the UIComponent associated with the closest parent UIComponent tag. This actionListener will cause the value given by the \"value\" attribute to be set into the ValueExpression given by the \"target\" attribute. The implementation of this tag creates a special ActionListener instance and registers it on the ActionSource associated with our most immediate surrounding instance of a tag whose implementation class is a subclass of UIComponentTag. This tag creates no output to the page currently being created. The ActionListener instance created and installed by this tag has the following behavior and contract.  Only create and register the ActionListener instance the first time the component for this tag is created The \"target\" and \"value\" tag attributes are ValueExpression instances and are stored unevaluated as instance variables of the listener. When the listener executes, perform the following:  Call getValue() on the \"value\" ValueExpression.   If value of the \"value\" expression is null, call setValue() on the \"target\" ValueExpression with the null value.   If the value of the \"value\" expression is not null, call getType() on the \"value\" and \"target\" ValueExpressions to determine their property types.   Coerce the value of the \"value\" expression to the \"target\" expression value type following the Expression Language coercion rules. Call setValue() on the \"target\" ValueExpression with the resulting value.   If either coercion or the execution of setValue() fails throw an AbortProcessingException.",
        "attribute": [
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "ValueExpression that is the destination of the value attribute.",
            "name": "target",
            "required": "true",
            "type": "java.lang.String"
          },
          {
            "description": "ValueExpression to be stored as the value of the target attribute.",
            "name": "value",
            "required": "true",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "subview",
        "description": "Naming Container tag for all Jakarta Faces core and component tags. It is particularly useful when a nested section included via <ui:include> or any tag that dynamically includes another page is included more than once, potentially causing duplicate component IDs. Each of those nested sections can then be wrapped in its own <f:subview> with each an unique id.",
        "attribute": [
          {
            "description": "Value binding expression to a backing bean property bound to the component instance for the UIComponent created by this tag.",
            "name": "binding",
            "type": "jakarta.faces.component.UIComponent"
          },
          {
            "description": "Component identifier of the UINamingContainer component to be created.",
            "name": "id",
            "required": "true",
            "type": "java.lang.String"
          },
          {
            "description": "Flag indicating whether this component (and its children) should be rendered. Expressions must evaluate to a boolean.",
            "name": "rendered",
            "type": "java.lang.Boolean"
          }
        ]
      },
      {
        "name": "validateBean",
        "description": "A validator that delegates the validation of the local value to the Bean Validation API. The validationGroups attribute serves as a filter that instructs the Bean Validation API which contraints to enforce. If there are any constraint violations reported by Bean Validation, the value is considered invalid. An instance of this validator can participate in class-level validation provided the preconditions mentioned in <f:validateWholeBean /> are met. Please see the documentation for <f:validateWholeBean /> and jakarta.faces.validator.BeanValidator.validate() for the specification and usage example.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an instance of BeanValidator.",
            "name": "binding",
            "type": "jakarta.faces.validator.BeanValidator"
          },
          {
            "description": "A boolean value enabling page level determination of whether or not this validator is enabled on the enclosing component.",
            "name": "disabled",
            "type": "java.lang.Boolean"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "A comma-separated list of validation groups. A validation group is a fully-qualified class name.",
            "name": "validationGroups",
            "required": "false",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "validateDoubleRange",
        "description": "Register a DoubleRangeValidator instance on the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an instance of DoubleRangeValidator.",
            "name": "binding",
            "type": "jakarta.faces.validator.DoubleRangeValidator"
          },
          {
            "description": "A boolean value enabling page level determination of whether or not this validator is enabled on the enclosing component.",
            "name": "disabled",
            "type": "java.lang.Boolean"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Maximum value allowed for this component.",
            "name": "maximum",
            "type": "java.lang.Double"
          },
          {
            "description": "Minimum value allowed for this component.",
            "name": "minimum",
            "type": "java.lang.Double"
          }
        ]
      },
      {
        "name": "validateLength",
        "description": "Register a LengthValidator instance on the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an instance of LengthValidator.",
            "name": "binding",
            "type": "jakarta.faces.validator.LengthValidator"
          },
          {
            "description": "A boolean value enabling page level determination of whether or not this validator is enabled on the enclosing component.",
            "name": "disabled",
            "type": "java.lang.Boolean"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Maximum length allowed for this component.",
            "name": "maximum",
            "type": "java.lang.Integer"
          },
          {
            "description": "Minimum length allowed for this component.",
            "name": "minimum",
            "type": "java.lang.Integer"
          }
        ]
      },
      {
        "name": "validateLongRange",
        "description": "Register a LongRangeValidator instance on the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an instance of LongRangeValidator.",
            "name": "binding",
            "type": "jakarta.faces.validator.LongRangeValidator"
          },
          {
            "description": "A boolean value enabling page level determination of whether or not this validator is enabled on the enclosing component.",
            "name": "disabled",
            "type": "java.lang.Boolean"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Maximum value allowed for this component.",
            "name": "maximum",
            "type": "java.lang.Long"
          },
          {
            "description": "Minimum value allowed for this component.",
            "name": "minimum",
            "type": "java.lang.Long"
          }
        ]
      },
      {
        "name": "validateRegex",
        "description": "A validator that uses the pattern attribute to validate the wrapping component. The entire pattern is matched against the String value of the component. If it matches, it's valid.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an instance of RegexValidator.",
            "name": "binding",
            "type": "jakarta.faces.validator.RegexValidator"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "A boolean value enabling page level determination of whether or not this validator is enabled on the enclosing component.",
            "name": "disabled",
            "type": "java.lang.Boolean"
          },
          {
            "description": "A regular expression pattern. Remember that, like in all Java strings, backslash must be escaped with another backslash.",
            "name": "pattern",
            "required": "true",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "validateRequired",
        "description": "A validator that enforces the presence of a value. It has the same affect as setting the required attribute on a UIInput to true.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an instance of RequiredValidator.",
            "name": "binding",
            "type": "jakarta.faces.validator.RequiredValidator"
          },
          {
            "description": "A boolean value enabling page level determination of whether or not this validator is enabled on the enclosing component.",
            "name": "disabled",
            "type": "java.lang.Boolean"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "validateWholeBean",
        "description": "Support multi-field validation by enabling class-level bean validation on CDI based backing beans. This feature causes a temporary copy of the bean referenced by the value attribute, for the sole purpose of populating the bean with field values already validated by <f:validateBean /> and then performing class-level validation on the copy. Regardless of the result of the class-level validation, the copy is discarded. This feature must explicitly be enabled by setting the application parameter specified in the javadoc for the symbolic constant jakarta.faces.validator.BeanValidator.ENABLE_VALIDATE_WHOLE_BEAN_PARAM_NAME. If this parameter is not set, or is set to false, this tag must be a no-op. A non-normative example follows the specification of the feature.  At a high level, the feature provides for a UIInput subclass that maintains its own special private Validator that uses information from one or more <f:validateBean />s to perform class-level bean validation. For discussion, this special Validator is called the wholeBeanValidator. This tag must be backed by a UIInput component with the following specializations.  Override getSubmittedValue() to return a non-null non empty String. This allows UIInput.validate() to call wholeBeanValidator.validate(). Override setConverter() to be a no-op. It does not make sense to allow a converter to be installed. Override addValidator() to be a no-op unless the argument is an instance of wholeBeanValidator. It does not make sense to allow additional validators to be installed. Override validate() to take the following actions.  If the feature is not enabled, return immediately. If the wholeBeanValidator has not yet been installed, instantiate and pass it to this.addValidator(). Call super.validate().    The wholeBeanValidator must have a validate() method that performs the following actions. Due to the above specification, this method will only ever be passed the special UIInput component.  Resolve the value of the component to its Object. Assume that this value is the bean whose properties are intended to be populated by components whose values are each validated by <f:validateBean /> tags. For discussion, this bean is called the candidate bean and the properties and their respective values are called the candidate values. If the candidate bean cannot be referenced, return immediately from validate(). Use the information recorded by each of those <f:validateBean /> tags to ensure that none of the candidate values are invalid. If any of them are invalid, return immediately from validate(). This ensures class-level validation is only performed on an instance whose fields are all individually valid. Otherwise it can be assumed that all field-level validations for this class-level validation have passed. Class-level bean validation must operate on a sufficiently populated bean instance. This differs from Faces field-level validation, which prevents beans from being populated with invalid values. To accomodate this difference, the candidate bean must be copied, populated with the already-validated candidate values, and then subjected to class-level validation. The copying must proceed in the following order.  Invoke the newInstance() method on the bean's Class. If this throws any Exception, swallow it and continue. If the bean implements Serializable, use that to copy the bean instance. Otherwise, if the bean implements Cloneable, clone the bean instance. Otherwise, if the bean has a copy constructor, use that to copy the bean instance. If none of these techniques yields a copy, throw FacesException.  Populate the copied bean with the candidate values. Obtain a reference to a jakarta.validation.Validator instance using the same steps described in the javadoc for jakarta.faces.validator.BeanValidator.validate(). Let the instance be called beanValidator for discussion. Obtain the value of the validationGroups attribute using the same steps described in the javadoc for jakarta.faces.validator.BeanValidator.validate(). If this value is not present or not valid, throw FacesException. Call the validate method on beanValidator, passing the populated copied bean and the validation groups as arguments. The copied bean can be discarded at this point. If the returned Set<ConstraintViolation> is non-empty, for each element in the Set, create a FacesMessage where the summary and detail are the return from calling ConstraintViolation.getMessage(). Capture all such FacesMessage instances into a Collection and pass them to ValidatorException. Using information recorded by the <f:validateBean /> tag(s), call setValid(false) on all of the components whose values contributed to this class-level validation. This is essential to prevent the invalid value from being set into the model during the update model values phase. Finally, throw the exception.  This tag must be placed in the component tree after all of the fields that are to be included in the multi-field validation. If this precondition is not met, the results of applying this tag are unspecified. This tag must be used in concert with <f:validateBean /> and Bean Validation. Here is a brief example of the common case of ensuring two password fields are individually valid and also both the same. The feature requires the use of the validationGroups attribute on all of the <f:validateBean /> tags and the <f:validateWholeBean /> tag. First, the ConstraintValidator implementation. public class PasswordValidator implements ConstraintValidator<Password, PasswordHolder> { @Override public void initialize(Password constraintAnnotation) { } @Override public boolean isValid(PasswordHolder value, ConstraintValidatorContext context) { boolean result; result = value.getPassword1().equals(value.getPassword2()); return result; } } Note that a PasswordHolder instance is passed to the isValid() method. This method will only be called if the individual properties of the PasswordHolder are valid. This fact allows the isValid() method to inspect the properties and perform effective class-level validtion. Next, the Constraint. @Constraint(validatedBy=PasswordValidator.class)@Target(TYPE)@Retention(RUNTIME)@interface Password { String message() default \"Password fields must match\"; Class[] groups() default {}; Class[] payload() default {};} Now the backing bean constrained by this Constraint. Note the use of groups. Note the fact that the bean implements Cloneable. @Named@RequestScoped@Password(groups = PasswordValidationGroup.class)public class BackingBean implements PasswordHolder, Cloneable { private String password1; private String password2; public BackingBean() { password1=\"\"; password2=\"\"; } @Override protected Object clone() throws CloneNotSupportedException { BackingBean other = (BackingBean) super.clone(); other.setPassword1(this.getPassword1()); other.setPassword2(this.getPassword2()); return other; } @NotNull(groups=PasswordValidationGroup.class) @Size(max=16, min=8, message=\"Password must be between 8 and 16 characters long\", groups = PasswordValidationGroup.class) @Override public String getPassword1() { return password1; } public void setPassword1(String password1) { this.password1 = password1; } @NotNull(groups=PasswordValidationGroup.class) @Size(max=16, min=8, message=\"Password must be between 8 and 16 characters long\", groups = PasswordValidationGroup.class) @Override public String getPassword2() { return password2; } public void setPassword2(String password2) { this.password2 = password2; } } Finally, the Facelets view.<h:panelGrid columns=\"2\"> <h:outputText value=\"Password\" /> <h:inputSecret id=\"password1\" value='#{backingBean.password1}'> <f:validateBean validationGroups=\"PasswordValidationGroup\" /> </h:inputSecret> <h:outputText value=\"Password again\" /> <h:inputSecret id=\"password2\" value='#{backingBean.password2}'> <f:validateBean validationGroups=\"PasswordValidationGroup\" /> </h:inputSecret> </h:panelGrid> <f:validateWholeBean value='#{backingBean}' validationGroups=\"PasswordValidationGroup\" />",
        "attribute": [
          {
            "description": "A boolean value enabling or disabling this validation component.",
            "name": "disabled",
            "required": "false",
            "type": "java.lang.Boolean"
          },
          {
            "description": "Component identifier of the UIInput component to be created.",
            "name": "id",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "A comma-separated list of validation groups. A validation group is a fully-qualified class name.",
            "name": "validationGroups",
            "required": "true",
            "type": "java.lang.String"
          },
          {
            "description": "A ValueExpression referencing the bean to be validated.",
            "name": "value",
            "required": "true",
            "type": "java.lang.Object"
          }
        ]
      },
      {
        "name": "validator",
        "description": "Register a named Validator instance on the UIComponent associated with the closest parent UIComponent tag.  Usage outside of an EditableValueHolder parent If this element is nested within a UIComponent tag that has other UIComponent children, the validator will be automatically added to all the child components as well as this one. The implementation must ensure this occurs even if the parent of this element is not an instance of EditableValueHolder.",
        "attribute": [
          {
            "description": "A ValueExpression that evaluates to an object that implements the jakarta.faces.validator.Validator interface.",
            "name": "binding",
            "type": "jakarta.faces.validator.Validator"
          },
          {
            "description": "A boolean value enabling page level determination of whether or not this validator is enabled on the enclosing component.",
            "name": "disabled",
            "type": "java.lang.Boolean"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Validator identifier of the Validator to be created and registered.",
            "name": "validatorId",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "valueChangeListener",
        "description": "Register a ValueChangeListener instance on the UIComponent associated with the closest parent UIComponent tag.",
        "attribute": [
          {
            "description": "Value binding expression that evaluates to an object that implements jakarta.faces.event.ValueChangeListener.",
            "name": "binding",
            "required": "false",
            "type": "jakarta.faces.event.ValueChangeListener"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Fully qualified Java class name of a ValueChangeListener to be created and registered.",
            "name": "type",
            "type": "java.lang.String"
          }
        ]
      },
      {
        "name": "view",
        "description": "Container for all Jakarta Faces core and component tags used on a page.",
        "attribute": [
          {
            "description": "MethodBinding pointing to a method that takes a jakarta.faces.event.PhaseEvent and returns void. This method will be called after every phase except for restore view on an initial request.",
            "name": "afterPhase",
            "required": "false",
            "method-signature": "void afterPhase(jakarta.faces.event.PhaseEvent)"
          },
          {
            "description": "MethodBinding pointing to a method that takes a jakarta.faces.event.PhaseEvent and returns void. This method will be called before every phase except for restore view.",
            "name": "beforePhase",
            "required": "false",
            "method-signature": "void beforePhase(jakarta.faces.event.PhaseEvent)"
          },
          {
            "description": "Specifies the content-type of the response.",
            "name": "contentType",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "A comma separated list of resource library contracts that may be used from within the Facelets chain. If this attribute is present, it must only be on the outer-most file in the chain of files that started ultimately with a call to ViewDeclarationLanguage.createView(). Any use of this attribute on a non-outer-most file is undefined. If this attribute exists on the tag, empty or not, the tag handler must create a List<String> for the value of the attribute and unconditionally call FacesContext.setRresourceLibraryContracts() passing that list value.",
            "name": "contracts",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Specifies the character encoding that should be used for the response.",
            "name": "encoding",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Locale to use for localizing this page. Expressions must evaluate to a java.util.Locale or to a String that is converted to a Locale.",
            "name": "locale",
            "type": "java.lang.Object"
          },
          {
            "description": "Identifier for the RenderKit to use for rendering this page.",
            "name": "renderKitId",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "If true, this view must not participate in state saving or restoring. Note that transient views may not be used with @ViewScoped managed beans. The implementation must call setTransient() on the UIViewRoot, passing the value of the attribute as specified in the markup.",
            "name": "transient",
            "required": "false",
            "type": "java.lang.Boolean"
          }
        ]
      },
      {
        "name": "viewAction",
        "description": "This action component specifies an application-specific command (or action), using an EL method expression, to be invoked during one of the Faces lifecycle phases, by default Invoke Application.",
        "attribute": [
          {
            "description": "MethodExpression representing the application action to invoke when this component is activated by the user. The expression must evaluate to a public method that takes no parameters, and returns an Object (the toString() of which is called to derive the logical outcome) which is passed to the NavigationHandler for this application.",
            "name": "action",
            "required": "true",
            "method-signature": "public java.lang.Object action()"
          },
          {
            "description": "MethodExpression representing an action listener method that will be notified when this component is activated by the user. The expression must evaluate to a public method that takes an ActionEvent parameter, with a return type of void, or to a public method that takes no arguments with a return type of void. In the latter case, the method has no way of easily knowing where the event came from, but this can be useful in cases where a notification is needed that \"some action happened\".",
            "name": "actionListener",
            "required": "false",
            "method-signature": "public void actionListener(jakarta.faces.event.ActionEvent)"
          },
          {
            "description": "Flag indicating that, if this component is activated by the user, notifications should be delivered to interested listeners and actions immediately (that is, during Apply Request Values phase) rather than waiting until Invoke Application phase.",
            "name": "immediate",
            "required": "false",
            "type": "java.lang.Boolean"
          },
          {
            "description": "View actions are most commonly used on the initial view request. Therefore, view actions do not operate on postback, by default. This attribute enables a view action to operate on postback.",
            "name": "onPostback",
            "required": "false",
            "type": "java.lang.Boolean"
          },
          {
            "description": "Specifies the phase in which the action invocation should occur using the name of the phase constant in the PhaseId class (the case does not matter). The value must be one of APPLY_REQUEST_VALUES, PROCESS_VALIDATIONS, UPDATE_MODEL_VALUES, or INVOKE_APPLICATION. The default is INVOKE_APPLICATION.",
            "name": "phase",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Like all children of <f:metadata>, a view action has no visual representation in the view. This attribute has exactly the same effect on a view action as the rendered attribute has on a visual component. Specifically, if the value of this attribute evaluates to false the component has no effect.",
            "name": "if",
            "required": "false",
            "type": "java.lang.Boolean"
          }
        ]
      },
      {
        "name": "viewParam",
        "description": "Used inside of the metadata facet of a view, this tag causes a UIViewParameter to be attached as metadata for the current view. Because UIViewParameter extends UIInput all of the attributes and nested child content for any UIInput tags are valid on this tag as well.",
        "attribute": [
          {
            "description": "The ValueExpression linking this component to a property in a backing bean.",
            "name": "binding",
            "required": "false",
            "type": "jakarta.faces.component.UIComponent"
          },
          {
            "description": "Converter instance registered with this component.",
            "name": "converter",
            "required": "false",
            "type": "jakarta.faces.convert.Converter"
          },
          {
            "description": "A ValueExpression enabled attribute that, if present, will be used as the text of the converter message, replacing any message that comes from the converter.",
            "name": "converterMessage",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "If present, this attribute refers to the value of one of the exposed attached objects within the composite component inside of which this tag is nested.",
            "name": "for",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "The component identifier for this component. This value must be unique within the closest parent component that is a naming container.",
            "name": "id",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "The name of the request parameter from which the value for this component is retrieved on an initial request or to override the stored value on a postback.",
            "name": "name",
            "required": "true",
            "type": "java.lang.String"
          },
          {
            "description": "Flag indicating that the user is required to provide a submitted value for this input component.",
            "name": "required",
            "required": "false",
            "type": "boolean"
          },
          {
            "description": "A ValueExpression enabled attribute that, if present, will be used as the text of the validation message for the \"required\" facility, if the \"required\" facility is used.",
            "name": "requiredMessage",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "MethodExpression representing a validator method that will be called during Process Validations to perform correctness checks on the value of this component. The expression must evaluate to a public method that takes FacesContext, UIComponent, and Object parameters, with a return type of void.",
            "name": "validator",
            "required": "false",
            "method-signature": "void validate(jakarta.faces.context.FacesContext, jakarta.faces.component.UIComponent, java.lang.Object)"
          },
          {
            "description": "A ValueExpression enabled attribute that, if present, will be used as the text of the validator message, replacing any message that comes from the validator.",
            "name": "validatorMessage",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "A ValueExpression to which the value of the request parameter, as determined by the name attribute, is bound. The resolved value of this expression is used when encoding the view parameter into a bookmarkable link or redirect URL with view parameter encoding enabled. If this attribute is omitted, the value of the request parameter will instead be the local value of the UIViewParameter.",
            "name": "value",
            "required": "false",
            "type": "java.lang.Object"
          },
          {
            "description": "MethodExpression representing a value change listener method that will be notified when a new value has been set for this input component. The expression must evaluate to a public method that takes a ValueChangeEvent parameter, with a return type of void, or to a public method that takes no arguments with a return type of void. In the latter case, the method has no way of easily knowing what the new value is, but this can be useful in cases where a notification is needed that \"this value changed\".",
            "name": "valueChangeListener",
            "required": "false",
            "method-signature": "void valueChange(jakarta.faces.event.ValueChangeEvent)"
          },
          {
            "description": "The maximum number of characters that may be entered in this field.",
            "name": "maxlength",
            "required": "false",
            "type": "int"
          }
        ]
      },
      {
        "name": "websocket",
        "description": "Registers a websocket push connection in client side by rendering the necessary scripts. Push messages can be sent from server side via jakarta.faces.push.PushContext interface. See also jakarta.faces.push.Push API documentation for an elaborate instruction on how to use <f:websocket>.",
        "attribute": [
          {
            "description": "Value binding expression to a backing bean property bound to the component instance for the UIComponent created by this tag.",
            "name": "binding",
            "required": "false",
            "type": "jakarta.faces.component.UIComponent"
          },
          {
            "description": "Component identifier of the UIWebsocket component to be created.",
            "name": "id",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "The name of the websocket channel. It may not be an EL expression and it may only contain alphanumeric characters, hyphens, underscores and periods. All open websockets on the same channel name will receive the same push notification from the server.",
            "name": "channel",
            "required": "true"
          },
          {
            "description": "The scope of the websocket channel. It may not be an EL expression and allowed values are application, session and view, case insensitive. When the value is application, then all channels with the same name throughout the application will receive the same push message. When the value is session, then only the channels with the same name in the current user session will receive the same push message. When the value is view, then only the channel in the current view will receive the push message. The default scope is application. When the user attribute is specified, then the default scope is session.",
            "name": "scope",
            "required": "false"
          },
          {
            "description": "The user identifier of the websocket channel, so that user-targeted push messages can be sent. It must implement Serializable and preferably have low memory footprint. Suggestion: use #{request.remoteUser} or #{someLoggedInUser.id}. All open websockets on the same channel and user will receive the same push message from the server.",
            "name": "user",
            "required": "false",
            "type": "java.io.Serializable"
          },
          {
            "description": "The JavaScript event handler function that is invoked when the websocket is opened. The function will be invoked with one argument: the channel name.",
            "name": "onopen",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "The JavaScript event handler function that is invoked when a push message is received from the server. The function will be invoked with three arguments: the push message, the channel name and the raw MessageEvent itself.",
            "name": "onmessage",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "The JavaScript event handler function that is invoked when a connection error has occurred and the websocket will attempt to reconnect. The function will be invoked with three arguments: the error reason code, the channel name and the raw CloseEvent itself. Note that this will not be invoked on final close of the websocket, even when the final close is caused by an error. See also RFC 6455 section 7.4.1 and CloseCodes API for an elaborate list of all close codes.",
            "name": "onerror",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "The JavaScript event handler function that is invoked when the websocket is closed and will not anymore attempt to reconnect. The function will be invoked with three arguments: the close reason code, the channel name and the raw CloseEvent itself. Note that this will also be invoked when the close is caused by an error and that you can inspect the close reason code if an actual connection error occurred and which one (i.e. when the code is not 1000 or 1008). See also RFC 6455 section 7.4.1 and CloseCodes API for an elaborate list of all close codes.",
            "name": "onclose",
            "required": "false",
            "type": "java.lang.String"
          },
          {
            "description": "Whether to (auto)connect the websocket or not. Defaults to true. It's interpreted as a JavaScript instruction whether to open or close the websocket push connection. This attribute is implicitly re-evaluated on every ajax request by a PreRenderViewEvent listener on the UIViewRoot. You can also explicitly set it to false and then manually control in JavaScript by faces.push.open(clientId) and faces.push.close(clientId).",
            "name": "connected",
            "required": "false",
            "type": "java.lang.Boolean"
          },
          {
            "description": "Whether to render the websocket scripts or not. Defaults to true. This attribute is implicitly re-evaluated on every ajax request by a PreRenderViewEvent listener on the UIViewRoot. If the value changes to false while the websocket is already opened, then the websocket will implicitly be closed.",
            "name": "rendered",
            "required": "false",
            "type": "java.lang.Boolean"
          }
        ]
      }
    ]
  }
}